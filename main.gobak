package main

import (
	"fazure/types"
	"fazure/views"
	"fmt"
	"os"
	"time"

	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/textinput"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
)

// Field indices for navigation
const (
	FieldDescription = iota
	FieldAddComment
	// Add more fields here as we enable editing for them
	FieldCount // Total number of editable fields
)

type model struct {
	textInput          textinput.Model
	table              table.Model
	viewport           viewport.Model
	textarea           textarea.Model
	azureClient        *MockAzureClient
	searchResult       []types.BacklogItem
	showResults        bool
	showDetail         bool
	editMode           bool
	savedItem          *types.BacklogItem  // Original saved state
	modifiedItem       *types.BacklogItem  // Current modified state
	selectedFieldIndex int                 // Which field is currently selected
	terminalWidth      int                 // Current terminal width
	terminalHeight     int                 // Current terminal height
	err                error
}

func initialModel() model {
	ti := textinput.New()
	ti.Placeholder = "Enter assignee name (e.g., john, sarah, mike, emma)"
	ti.Focus()
	ti.CharLimit = 50
	ti.Width = 60

	return model{
		textInput:   ti,
		azureClient: NewMockAzureClient(),
		showResults: false,
	}
}

func (m model) Init() tea.Cmd {
	return textinput.Blink
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.terminalWidth = msg.Width
		m.terminalHeight = msg.Height
		// Update viewport dimensions if in detail view
		if m.showDetail && m.modifiedItem != nil {
			contentWidth := m.getContentWidth()
			m.viewport = views.CreateCommentsViewport(m.modifiedItem, contentWidth)
		}
		return m, nil

	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			// Don't quit if in edit mode, let user explicitly cancel first
			if m.editMode {
				return m, nil
			}
			return m, tea.Quit

		case "esc":
			// Exit edit mode if editing
			if m.editMode {
				m.editMode = false
				return m, nil
			}
			// Navigate back through views
			if m.showDetail {
				// Go back from detail to table
				m.showDetail = false
				m.savedItem = nil
				m.modifiedItem = nil
				m.selectedFieldIndex = 0
				return m, nil
			} else if m.showResults {
				// Go back from table to search
				m.showResults = false
				m.textInput.SetValue("")
				m.textInput.Focus()
				return m, nil
			}

		case "up", "k":
			// Navigate to previous field when in detail view (not in edit mode)
			if m.showDetail && !m.editMode {
				if m.selectedFieldIndex > 0 {
					m.selectedFieldIndex--
				}
				return m, nil
			}

		case "down", "j":
			// Navigate to next field when in detail view (not in edit mode)
			if m.showDetail && !m.editMode {
				if m.selectedFieldIndex < FieldCount-1 {
					m.selectedFieldIndex++
				}
				return m, nil
			}

		case "pgdown", "ctrl+d":
			// Scroll comments down
			if m.showDetail && !m.editMode {
				m.viewport.LineDown(5)
				return m, nil
			}

		case "pgup", "ctrl+u":
			// Scroll comments up
			if m.showDetail && !m.editMode {
				m.viewport.LineUp(5)
				return m, nil
			}

		case "ctrl+s":
			if m.editMode && m.modifiedItem != nil {
				// Save the textarea value to the modified item
				switch m.selectedFieldIndex {
				case FieldDescription:
					m.modifiedItem.Description = m.textarea.Value()
				case FieldAddComment:
					// Add new comment if there's content
					commentText := m.textarea.Value()
					if commentText != "" {
						newComment := types.Comment{
							Author:  "Current User", // TODO: Get actual user
							Date:    time.Now().Format("2006-01-02 15:04"),
							Content: commentText,
						}
						// Prepend new comment to the beginning
						m.modifiedItem.Comments = append([]types.Comment{newComment}, m.modifiedItem.Comments...)
						// Refresh viewport with updated comments
						contentWidth := m.getContentWidth()
						m.viewport = views.CreateCommentsViewport(m.modifiedItem, contentWidth)
					}
				}
				m.editMode = false
				return m, nil
			} else if m.showDetail && !m.editMode && m.modifiedItem != nil && m.savedItem != nil {
				// Save modified item to saved item (commit changes)
				savedCopy := *m.modifiedItem
				m.savedItem = &savedCopy
				// Also update in the search results slice
				for i := range m.searchResult {
					if m.searchResult[i].ID == m.modifiedItem.ID {
						m.searchResult[i] = *m.modifiedItem
						break
					}
				}
				return m, nil
			}

		case "ctrl+r":
			// Revert changes (restore from saved item)
			if m.showDetail && !m.editMode && m.savedItem != nil {
				modifiedCopy := *m.savedItem
				m.modifiedItem = &modifiedCopy
				return m, nil
			}

		case "enter":
			if m.showDetail && !m.editMode {
				// Enter edit mode for the selected field
				if m.modifiedItem != nil {
					m.editMode = true
					// Initialize textarea based on selected field
					contentWidth := m.getContentWidth()
					ta := textarea.New()
					switch m.selectedFieldIndex {
					case FieldDescription:
						ta.SetValue(m.modifiedItem.Description)
					case FieldAddComment:
						ta.SetValue("") // Start with empty comment
					}
					ta.Focus()
					ta.SetWidth(contentWidth)
					ta.SetHeight(10)
					m.textarea = ta
					return m, nil
				}
			} else if m.showResults {
				// Open detail view for selected item
				selectedRow := m.table.Cursor()
				if selectedRow >= 0 && selectedRow < len(m.searchResult) {
					item := m.searchResult[selectedRow]
					// Create a copy for saved and modified states
					savedCopy := item
					modifiedCopy := item
					m.savedItem = &savedCopy
					m.modifiedItem = &modifiedCopy
					m.selectedFieldIndex = 0 // Start at first field
					m.showDetail = true
					contentWidth := m.getContentWidth()
					m.viewport = views.CreateCommentsViewport(m.modifiedItem, contentWidth)
					return m, nil
				}
			} else if !m.editMode {
				// Perform search
				searchName := m.textInput.Value()
				if searchName != "" {
					m.searchResult = m.azureClient.SearchWorkItems(searchName)
					m.showResults = true
					m.table = views.CreateTable(m.searchResult)
				}
				return m, nil
			}
		}
	}

	// Update the appropriate component based on current state
	if m.editMode {
		m.textarea, cmd = m.textarea.Update(msg)
	} else if m.showResults {
		m.table, cmd = m.table.Update(msg)
	} else if !m.showDetail {
		m.textInput, cmd = m.textInput.Update(msg)
	}

	return m, cmd
}

func (m model) View() string {
	contentWidth := m.getContentWidth()

	if m.editMode && m.modifiedItem != nil {
		return views.RenderEditView(m.modifiedItem, m.selectedFieldIndex, contentWidth, m.textarea.View())
	}

	if m.showDetail && m.modifiedItem != nil {
		// Check if item is dirty (modified != saved)
		isDirty := false
		if m.savedItem != nil {
			isDirty = !itemsEqual(m.savedItem, m.modifiedItem)
		}
		return views.RenderDetailView(m.modifiedItem, m.selectedFieldIndex, isDirty, contentWidth, m.viewport.View())
	}

	if m.showResults {
		return views.RenderTableView(m.textInput.Value(), m.table.View(), len(m.searchResult) > 0)
	}

	// Show search input
	return views.RenderSearchView(m.textInput.View())
}

// itemsEqual compares two BacklogItems for equality
func itemsEqual(a, b *types.BacklogItem) bool {
	if a == nil || b == nil {
		return a == b
	}
	// Compare editable fields
	if a.Description != b.Description {
		return false
	}
	// Compare comments count and content
	if len(a.Comments) != len(b.Comments) {
		return false
	}
	for i := range a.Comments {
		if a.Comments[i].Author != b.Comments[i].Author ||
			a.Comments[i].Date != b.Comments[i].Date ||
			a.Comments[i].Content != b.Comments[i].Content {
			return false
		}
	}
	return true
}

// getContentWidth returns half the terminal width, capped at 100
func (m model) getContentWidth() int {
	contentWidth := m.terminalWidth / 2
	if contentWidth > 100 {
		contentWidth = 100 // Cap at 100 for very wide terminals
	}
	if contentWidth < 40 {
		contentWidth = 40 // Minimum width for readability
	}
	return contentWidth
}

func main() {
	p := tea.NewProgram(initialModel(), tea.WithAltScreen())
	if _, err := p.Run(); err != nil {
		fmt.Printf("Error running program: %v\n", err)
		os.Exit(1)
	}
}
